Minimum viable product TODO:

[X] SAT solver:

    [X] DPLL algo
    [] (optional) 2-SAT polynomial time algorithm?
    [] (optional) conflict driven?

[X] Tseiten transformation

[] Expr parsing:

    [] Operators: and, or, not, (core) xor, nor, nand, if, iff (built on core)
    [] Global variables storing booleans and subexprs


[] Expr evaluation

[] Truth table generation


Not quite part of MVP TODO:

[] Free with SAT solver:
    
    [] Tautology checker
    [] Logical equivlance checker
    [] Argument checking
    [] Maybe CNF/DNF conversation?

[] Explict expr building from other exprs
    - Engine.or, Engine.and, ...

Maybe in future TODO:

[] Term rewritting/expr simplification

engine.gen_truth_table(engine.parse("x or y"))


Implementation plan:

* Parser: recursive decent
* Evaluation of proposition: bytecode vm


Example brainstorming

* General API: 


``
import * from easypls

engine = Engine()

# Variable definition
x = engine.def("x", True)

# Expr parsing and evaulation
expr = Expr.from("x or x")
print(engine.eval(expr))                            # Prints "True"

# Logical equivilace checking
engine.logically_eq(x, expr)                        # Returns True

# CNF conversion
cnf = Expr.parse("a -> b").into_cnf()

# SAT Solver
engine.is_sat(cnf)                                  # Returns True

args = [
    Expr.parse("a -> b"),
    Expr.parse("a"),
]

a = Expr.var("a")
b = Expr.var("b")

raw_cnf = engine.cnf_from_arr([[a, b], [a, b.negated()]])
new_cnf = engine.condition(a, Bool.T)

conclusion = engine.parse("b")

engine.is_valid_argument(args, conclusion)          # Returns True

`
