#[cfg(test)]
mod tests;

use pyo3::prelude::*;


// Representation of a boolean expression in conjunctive normal form

/// A Python module implemented in Rust.
#[pymodule]
pub mod easypls {
    use pyo3::prelude::*;

    #[pyclass]
    struct CNF {
        // symbol_table[id] represents symbol of variable with id
        symbol_table: Rc<Vec<String>>,

        // Outer list represents conjunction of inner lists which
        // represent disjunctions of variables, represented by their ids
        cnf: Vec<Vec<usize>>,
    }

    #[pymethods]
    impl CNF {
        fn find_unit_clauses(&self) -> Vec<usize> {
            let mut unit_clauses = Vec::new();
            for clause in self.cnf.iter() {
                if clause.len() == 0 {
                    unit_clauses.push(clause[0]);
                }
            }
            unit_clauses
        }

        fn condition(&mut self, var: usize) {
        }

        // Returns whether a CNF is satisfiable
        // if so we return the signature that makes the CNF true.
        // otherwise we return None
        fn is_sat_aux(&self, conditioned: usize) -> Option<Vec<usize>> {
            // Unit propigation
            // Check if there are no clauses remaining, if so return true
            // Check if there are any empty clauses, if so return false
            // Condition on the next variable
        }
    }
}
